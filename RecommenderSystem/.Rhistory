as(recommend1, "list")
as(recommend2, "list")
as(recommend3, "list")
recom <- HybridRecommender(
Recommender(sampleData, method = "IBCF"),
Recommender(sampleData, method = "UBCF"),
weights = c(.6, .4)
)
getModel(recom)
as(predict(recom, sampleData[1001]), "list")
scheme <- evaluationScheme(sampleData, method = "split", train = 0.8, given = 10)
rec1a <- Recommender(getData(scheme, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme, "known"), type = "topNList", n = 10)
error1a <- calcPredictionAccuracy(pred1a, getData(scheme, "unknown"), given = 10, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme, "unknown"), given = 10, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme, "unknown"), given = 10, goodRating = 1)
errorList <- rbind(error1a, error2a, error3a)
rownames(errorList) <- c("IBCF","UBCF", "POPULARITY")
errorList
scheme <- evaluationScheme(sampleData, method = "split", train = 0.8, given = 4)
rec1a <- Recommender(getData(scheme, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme, "known"), type = "topNList", n = 10)
error1a <- calcPredictionAccuracy(pred1a, getData(scheme, "unknown"), given = 4, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme, "unknown"), given = 4, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme, "unknown"), given = 4, goodRating = 1)
scheme <- evaluationScheme(sampleData, method = "split", train = 0.8, given = 1)
rec1a <- Recommender(getData(scheme, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme, "known"), type = "topNList", n = 10)
error1a <- calcPredictionAccuracy(pred1a, getData(scheme, "unknown"), given = 1, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme, "unknown"), given = 1, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme, "unknown"), given = 1, goodRating = 1)
errorList <- rbind(error1a, error2a, error3a)
rownames(errorList) <- c("IBCF","UBCF", "POPULARITY")
errorList
rec1a
pred1a
pred2a
as(pred1a, "list")
as(pred2a, "list")
as(pred3a, "list")
as(pred1a, "list")
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
library(tidyverse)
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData <- sampleData[sum1 > 3, ] # retain only those who rated atleast 4 items
sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData <- sampleData[, c("sum1", "sum2") := NULL] # remove the "sum" variable
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData <- sampleData[sum1 > 3, ] # retain only those who rated atleast 4 items
'sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData <- sampleData[, c("sum1", "sum2") := NULL] # remove the "sum" variable
'
sampleData <- as(sampleData, "binaryRatingMatrix")
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData1 <- sampleData[sum1 > 3, ] # retain only those who rated atleast 4 items
sampleData1 <- sampleData1[, sum1 := NULL] # remove the "sum" variable
sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData2 <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData2 <- sampleData2[, sum2 := NULL] # remove the "sum" variable
sampleData1 <- as(sampleData1, "binaryRatingMatrix")
sampleData2 <- as(sampleData2, "binaryRatingMatrix")
# corTable <- cor(sampleData)
# CREATE AN EVALUATION SCHEME
scheme1 <- evaluationScheme(sampleData1, method = "split", train = 0.8, given = 1)
scheme2 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 1)
rec1a <- Recommender(getData(scheme1, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme2, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme1, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme1, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme2, "known"), type = "topNList", n = 10)
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData1 <- sampleData[sum1 > 3, ] # retain only those who rated atleast 4 items
sampleData1 <- sampleData1[, sum1 := NULL] # remove the "sum" variable
sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData2 <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData2 <- sampleData2[, sum2 := NULL] # remove the "sum" variable
sampleData1 <- as(sampleData1, "binaryRatingMatrix")
sampleData2 <- as(sampleData2, "binaryRatingMatrix")
# corTable <- cor(sampleData)
# r1 <- Recommender(sampleData[c(1:34299), ], method = "POPULAR")
# r2 <- Recommender(sampleData[c(1:34299), ],  method = "UBCF")
# r3 <- Recommender(sampleData[c(1:34299), ],  method = "IBCF")
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 50)
scheme2 <- evaluationScheme(sampleData1, method = "split", train = 0.8, given = 4)
rec1a <- Recommender(getData(scheme1, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme2, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme2, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme1, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme2, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme2, "known"), type = "topNList", n = 10)
a <- as(pred1a, "list")
b <- as(pred2a, "list")
c <- as(pred3a, "list")
error1a <- calcPredictionAccuracy(pred1a, getData(scheme1, "unknown"), given = 50, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme2, "unknown"), given = 4, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme2, "unknown"), given = 4, goodRating = 1)
errorList <- rbind(error1a, error2a, error3a)
rownames(errorList) <- c("IBCF","UBCF", "POPULARITY")
errorList
## THIS IS JUST A SAMPLE RECOMMENDER -> A USER BASED COLLABORATIVE FILTERING
## THE DATA WAS THE DEMOGRAPHICS
## NO EXHIBITOR VISIT DATA WAS INCLUDED
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
data("MovieLense")
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData1 <- sampleData[sum1 > 5, ] # retain only those who rated atleast 4 items
sampleData1 <- sampleData1[, sum1 := NULL] # remove the "sum" variable
sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData2 <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData2 <- sampleData2[, sum2 := NULL] # remove the "sum" variable
sampleData1 <- as(sampleData1, "binaryRatingMatrix")
sampleData2 <- as(sampleData2, "binaryRatingMatrix")
# corTable <- cor(sampleData)
# r1 <- Recommender(sampleData[c(1:34299), ], method = "POPULAR")
# r2 <- Recommender(sampleData[c(1:34299), ],  method = "UBCF")
# r3 <- Recommender(sampleData[c(1:34299), ],  method = "IBCF")
'
rec1 <- Recommender(sampleData, method = "IBCF")
recommend1 <- predict(rec1, sampleData[1000], type = "topNList")
rec2 <- Recommender(sampleData, method = "UBCF")
recommend2 <- predict(rec2, sampleData[1000], type = "topNList")
rec3 <- Recommender(sampleData, method = "POPULAR")
recommend3 <- predict(rec3, sampleData[1000], type = "topNList")
as(recommend1, "list")
as(recommend2, "list")
as(recommend3, "list")
# HYBRID RECOMMENDER
recom <- HybridRecommender(
Recommender(sampleData, method = "IBCF"),
Recommender(sampleData, method = "UBCF"),
weights = c(.6, .4)
)
getModel(recom)
as(predict(recom, sampleData[1001]), "list")
'
# CREATE AN EVALUATION SCHEME
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 5)
scheme2 <- evaluationScheme(sampleData1, method = "split", train = 0.8, given = 5)
rec1a <- Recommender(getData(scheme1, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme2, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme2, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme1, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme2, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme2, "known"), type = "topNList", n = 10)
a <- as(pred1a, "list")
b <- as(pred2a, "list")
c <- as(pred3a, "list")
error1a <- calcPredictionAccuracy(pred1a, getData(scheme1, "unknown"), given = 5, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme2, "unknown"), given = 5, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme2, "unknown"), given = 5, goodRating = 1)
errorList <- rbind(error1a, error2a, error3a)
rownames(errorList) <- c("IBCF","UBCF", "POPULARITY")
errorList
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 1)
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 2)
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 1)
scheme2 <- evaluationScheme(sampleData1, method = "split", train = 0.8, given = 5)
rec1a <- Recommender(getData(scheme1, "train"), method = "IBCF")
rec2a <- Recommender(getData(scheme2, "train"), method = "UBCF")
rec3a <- Recommender(getData(scheme2, "train"), method = "POPULAR")
pred1a <- predict(rec1a, getData(scheme1, "known"), type = "topNList", n = 10)
pred2a <- predict(rec2a, getData(scheme2, "known"), type = "topNList", n = 10)
pred3a <- predict(rec3a, getData(scheme2, "known"), type = "topNList", n = 10)
a <- as(pred1a, "list")
b <- as(pred2a, "list")
c <- as(pred3a, "list")
error1a <- calcPredictionAccuracy(pred1a, getData(scheme1, "unknown"), given = 1, goodRating = 1)
error2a <- calcPredictionAccuracy(pred2a, getData(scheme2, "unknown"), given = 5, goodRating = 1)
error3a <- calcPredictionAccuracy(pred3a, getData(scheme2, "unknown"), given = 5, goodRating = 1)
errorList <- rbind(error1a, error2a, error3a)
rownames(errorList) <- c("IBCF","UBCF", "POPULARITY")
errorList
## THIS IS THE MODEL TRAINER FOR THE RECOMMENDER SYSTEM
## IT USES KNN AS THE SIMILARITY ALGORITHM
## THE DATA UTILIZES THE DEMOGRAPHIC AS AN ADDITIONAL INFORMATION FOR THE MACHINE LEARNING ALGORITHM
rm(list = ls())
library(tidyverse)
library(data.table)
visitData <- readRDS("./RData/visitData.RData")
touchData <- readRDS("./RData/touchData.RData")
convoData <- readRDS("./RData/convoData.RData")
sourceData <- readRDS("./RData/sourceData.RData")
View(sourceData)
View(sourceData)
sourceData <- sourceData[, -c(1,2)]
sourceData <- as.matrix(sourceData)
model <- funkSVD(sourceData)
model <- funkSVD(sourceData, verbose = TRUE)
recom <- tcrossprod(model$U, model$V)
recom
MAE(sourceData, recom)
RMSE(sourceData, recom)
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum, breaks = 20) ## check the distribution
hist(sumsItems$sum, breaks = 5) ## check the distribution
hist(sumsItems$sum, breaks = 1) ## check the distribution
hist(sumsItems$sum, breaks = 100) ## check the distribution
hist(sumsItems$sum, breaks = 200) ## check the distribution
scheme2 <- evaluationScheme(sampleData1, method = "cross", k = 5, train = 0.8)
rm(list = ls())
library(tidyverse)
library(data.table)
library(recommenderlab)
sampleData <- readRDS("./RData/visitData.RData")
sampleData <- setDT(sampleData)
sampleData <- sampleData[rating != 0,]
# count the number of items per user
sumsItems <- sampleData %>% group_by(userID) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsItems$sum) ## check the summary
hist(sumsItems$sum, breaks = 200) ## check the distribution
# count the number of users per item
sumsUser <- sampleData %>% group_by(itemid) %>% summarise(sum = sum(rating)) ## check the number of rated items per user
summary(sumsUser$sum, breaks = 200) ## check the summary
hist(sumsUser$sum) ## check the distribution
sampleData <- sampleData[, sum1 := sum(rating), by = userID] # create a column for sum of ratings
sampleData1 <- sampleData[sum1 > 5, ] # retain only those who rated atleast 4 items
sampleData1 <- sampleData1[, sum1 := NULL] # remove the "sum" variable
sampleData <- sampleData[, sum2 := sum(rating), by = itemid] # create a column for sum of ratings
sampleData2 <- sampleData[sum2 > 49, ] # retain only those who rated atleast 4 items
sampleData2 <- sampleData2[, sum2 := NULL] # remove the "sum" variable
sampleData1 <- as(sampleData1, "binaryRatingMatrix")
sampleData2 <- as(sampleData2, "binaryRatingMatrix")
# corTable <- cor(sampleData)
# r1 <- Recommender(sampleData[c(1:34299), ], method = "POPULAR")
# r2 <- Recommender(sampleData[c(1:34299), ],  method = "UBCF")
# r3 <- Recommender(sampleData[c(1:34299), ],  method = "IBCF")
'
rec1 <- Recommender(sampleData, method = "IBCF")
recommend1 <- predict(rec1, sampleData[1000], type = "topNList")
rec2 <- Recommender(sampleData, method = "UBCF")
recommend2 <- predict(rec2, sampleData[1000], type = "topNList")
rec3 <- Recommender(sampleData, method = "POPULAR")
recommend3 <- predict(rec3, sampleData[1000], type = "topNList")
as(recommend1, "list")
as(recommend2, "list")
as(recommend3, "list")
# HYBRID RECOMMENDER
recom <- HybridRecommender(
Recommender(sampleData, method = "IBCF"),
Recommender(sampleData, method = "UBCF"),
weights = c(.6, .4)
)
getModel(recom)
as(predict(recom, sampleData[1001]), "list")
'
# CREATE AN EVALUATION SCHEME
scheme1 <- evaluationScheme(sampleData2, method = "split", train = 0.8, given = 1)
scheme2 <- evaluationScheme(sampleData1, method = "cross", k = 5, train = 0.8)
scheme2 <- evaluationScheme(sampleData1, method = "cross", k = 5, train = 0.8, given = 5)
results <- evaluate(scheme, method = "UBCF", n = c(5,10,15,20))
results <- evaluate(scheme2, method = "UBCF", n = c(5,10,15,20))
getConfusionMatrix(results)[[1]]
avg(results)
plot()
plot(results)
plot(results, annotate = TRUE)
results <- evaluate(scheme2, method = "UBCF", n = c(1,3,5,10,15,20))
getConfusionMatrix(results)[[1]]
avg(results)
plot(results, annotate = TRUE)
plot(results, "prec/rec", annotate = TRUE)
scheme2 <- evaluationScheme(sampleData1, method = "cross", train = 0.8, given = 3)
results <- evaluate(scheme2, method = "UBCF", n = c(1,3,5,10,15,20))
getConfusionMatrix(results)[[1]]
avg(results)
plot(results, annotate = TRUE)
plot(results, "prec/rec", annotate = TRUE)
compare <- evaluate(scheme2, method = "UBCF", n = c(1,3,5,10,15,20))
scheme2 <- evaluationScheme(sampleData1, method = "cross", train = 0.8, given = 3)
results <- evaluate(scheme2, method = "IBCF", n = c(1,3,5,10,15,20))
getConfusionMatrix(results)[[1]]
avg(results)
plot(results, annotate = TRUE)
plot(results, "prec/rec", annotate = TRUE)
results <- evaluate(scheme2, `user-based CF` = list(name = "UBCF", param = list(method = "Jaccard", nn = 50)), n = c(1,3,5,10,15,20))
results <- evaluate(scheme2, method = "UBCF", param = list(method = "Jaccard", nn = 50), n = c(1,3,5,10,15,20))
getConfusionMatrix(results)[[1]]
avg(results)
plot(results, annotate = TRUE)
plot(results, "prec/rec", annotate = TRUE)
algorithms <- list(`random items` = list(name = "RANDOM",
param = NULL), `popular items` = list(name = "POPULAR",
param = NULL), `user-based CF` = list(name = "UBCF",
param = list(method = "Jaccard", nn = 50)), `item-based CF` = list(name = "IBCF",
param = list(method = "Jaccard", k = 50)), `association rules` = list(name = "AR",
param = list(supp = 0.001, conf = 0.2, maxlen = 2)))
results <- evaluate(scheme2, algorithms, n = c(1, 3, 5, 10, 15, 20))
results <- evaluate(scheme2, algorithms, n = c(1, 3, 5, 10, 15, 20))
plot(results, annotate = c(1, 3), legend = "right")
plot(results, "prec/rec", annotate = 3)
recom <- HybridRecommender(
evaluate(scheme2, algorithms, n = c(1, 3, 5, 10, 15, 20)),
weights = c(.4, .6)
)
recom <- HybridRecommender(
evaluate(scheme2, algorithms, n = c(1, 3, 5, 10, 15, 20))
)
recom <- HybridRecommender(
evaluate(scheme1, method = "IBCF", param = list(method = "Jaccard", k = 50), n = c(1,3,5,10,15,20)),
evaluate(scheme2, method = "UBCF", param = list(method = "Jaccard", nn = 50), n = c(1,3,5,10,15,20)),
weights = c(.4, .6)
)
plot(recom, annotate = c(1, 3), legend = "right")
recom <- HybridRecommender(
Recommender(sampleData2, method = "IBCF"),
Recommender(sampleData1, method = "UBCF"),
weights = c(.4, .6)
)
plot(recom, annotate = c(1, 3), legend = "right")
plot(recom, legend = "right")
algorithms <- list(`random items` = list(name = "RANDOM",
param = NULL), `popular items` = list(name = "POPULAR",
param = NULL), `user-based CF` = list(name = "UBCF",
param = list(method = "Jaccard", nn = 50)), `item-based CF` = list(name = "IBCF",
param = list(method = "Jaccard", k = 50)), `association rules` = list(name = "AR",
param = list(supp = 0.001, conf = 0.2, maxlen = 2)))
results <- evaluate(scheme2, algorithms, n = c(1, 3, 5, 10, 15, 20, 100))
plot(results, annotate = c(1, 3), legend = "right")
plot(results, "prec/rec", annotate = 3)
results <- evaluate(scheme2, algorithms, n = seq(1:100, by = 5))
?seq
results <- evaluate(scheme2, algorithms, n = seq(from = 1, to = 100, by = 5))
plot(results, annotate = c(1, 3), legend = "right")
plot(results, "prec/rec", annotate = 3)
results <- evaluate(scheme2, algorithms, n = seq(from = 1, to = 1000, by = 100))
plot(results, annotate = c(1, 3), legend = "right")
plot(results, "prec/rec", annotate = 3)
install.packages("formatR")
reprex:::reprex_addin()
install.packages("shinyjs")
reprex:::reprex_addin()
his function
# in an R package, provide the registration metadata at
# 'inst/rstudio/addins.dcf', and you're ready to go!
library(shiny)
library(miniUI)
# We'll wrap our Shiny Gadget in an addin.
# Let's call it 'clockAddin()'.
clockAddin <- function() {
# Our ui will be a simple gadget page, which
# simply displays the time in a 'UI' output.
ui <- miniPage(
gadgetTitleBar("Clock"),
miniContentPanel(
uiOutput("time")
)
)
server <- function(input, output, session) {
# Set some CSS styles for our clock.
clockStyles <- paste(
"border: 1px solid #DADADA",
"background-color: #EFEFEF",
"border-radius: 5px",
"font-size: 6em",
"margin-top: 60px",
"text-align: center",
sep = "; "
)
# We'll use a 'reactiveTimer()' to force Shiny
# to update and show the clock every second.
invalidatePeriodically <- reactiveTimer(intervalMs = 1000)
observe({
# Call our reactive timer in an 'observe' function
# to ensure it's repeatedly fired.
invalidatePeriodically()
# Get the time, and render it as a large paragraph element.
time <- Sys.time()
output$time <- renderUI({
p(style = clockStyles, time)
})
})
# Listen for 'done' events. When we're finished, we'll
# insert the current time, and then stop the gadget.
observeEvent(input$done, {
timeText <- paste0("\"", as.character(Sys.time()), "\"")
rstudioapi::insertText(timeText)
stopApp()
})
}
# We'll use a pane viwer, and set the minimum height at
# 300px to ensure we get enough screen space to display the clock.
viewer <- paneViewer(300)
runGadget(ui, server, viewer = viewer)
}
# Try running the clock!
clockAddin()
# Now all that's left is sharing this addin -- put this function
# in an R package, provide the registration metadata at
# 'inst/rstudio/addins.dcf', and you're ready to go!
getwd()
formatR::tidy_source("./src/sample_recommender.R")
devtools::install_github("rstudio/addinexamples", type = "source")
addinexamples:::reformatAddin()
addinexamples:::reformatAddin()
